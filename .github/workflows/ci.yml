name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  GO_VERSION: '1.25'

jobs:
  # Detect what types of files have changed
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      code: ${{ steps.changes.outputs.code }}
      docs: ${{ steps.changes.outputs.docs }}
      ci: ${{ steps.changes.outputs.ci }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v6.0.0

    - name: Check for changes
      uses: dorny/paths-filter@v3
      id: changes
      with:
        filters: |
          code:
            - '**/*.go'
            - 'go.mod'
            - 'go.sum'
            - 'Makefile'
            - 'cmd/**'
            - 'pkg/**'
            - 'test/**'
          docs:
            - '**/*.md'
            - '**/*.txt'
            - '**/*.rst'
            - 'LICENSE'
          ci:
            - '.github/workflows/**'

  # Stage 1: Fast feedback with unit tests and linting
  unit-tests-and-lint:
    name: Unit Tests & Linting
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.code == 'true' || needs.changes.outputs.ci == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v6.0.0
      with:
        # Fetch full history for better golangci-lint performance
        fetch-depth: 0


    - name: Set up Go
      uses: actions/setup-go@v6.1.0
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Run gofumpt formatting check
      run: |
        go install mvdan.cc/gofumpt@latest
        if [ "$(gofumpt -l .)" != "" ]; then
          echo "Code is not properly formatted. Run 'make fmt-modern' to fix."
          gofumpt -l .
          exit 1
        fi

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v9.0.0
      with:
        version: latest
        args: --timeout=5m

    - name: Run unit tests
      run: make test-unit

    - name: Upload unit test results
      uses: actions/upload-artifact@v5
      if: always()
      with:
        name: unit-test-results
        path: |
          coverage.out
        retention-days: 30

  # Stage 2: Comprehensive testing in parallel
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [changes, unit-tests-and-lint]
    if: needs.changes.outputs.code == 'true' || needs.changes.outputs.ci == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v6.0.0


    - name: Set up Go
      uses: actions/setup-go@v6.1.0
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Set up envtest binaries
      run: make setup-envtest

    - name: Run integration tests
      run: |
        source test/envtest/env.sh
        make test-integration

    - name: Upload integration test results
      uses: actions/upload-artifact@v5
      if: always()
      with:
        name: integration-test-results
        path: |
          coverage.out
        retention-days: 30

  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: [changes, unit-tests-and-lint]
    if: needs.changes.outputs.code == 'true' || needs.changes.outputs.ci == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v6.0.0


    - name: Set up Go
      uses: actions/setup-go@v6.1.0
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Run E2E tests
      run: make test-e2e

    - name: Upload E2E test results
      uses: actions/upload-artifact@v5
      if: always()
      with:
        name: e2e-test-results
        path: |
          coverage.out
        retention-days: 30

  # Build and test binaries
  build:
    name: Build & Test Binaries
    runs-on: ${{ matrix.os }}
    needs: [changes, unit-tests-and-lint]
    if: needs.changes.outputs.code == 'true' || needs.changes.outputs.ci == 'true'
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        include:
        - os: ubuntu-latest
          binary-name: extendable-k8s-mcp-linux
        - os: macos-latest
          binary-name: extendable-k8s-mcp-darwin
    steps:
    - name: Checkout code
      uses: actions/checkout@v6.0.0


    - name: Set up Go
      uses: actions/setup-go@v6.1.0
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
        cache-dependency-path: go.sum

    - name: Download dependencies
      run: go mod download

    - name: Build binary
      run: make build

    - name: Test binary execution
      run: |
        ./build/extendable-k8s-mcp --version
        ./build/extendable-k8s-mcp --help

    - name: Upload binary artifact
      uses: actions/upload-artifact@v5
      with:
        name: ${{ matrix.binary-name }}
        path: build/extendable-k8s-mcp
        retention-days: 30

  # Coverage reporting (runs after all tests complete)
  coverage:
    name: Coverage Report
    runs-on: ubuntu-latest
    needs: [changes, integration-tests, e2e-tests]
    if: always() && (needs.changes.outputs.code == 'true' || needs.changes.outputs.ci == 'true')
    steps:
    - name: Checkout code
      uses: actions/checkout@v6.0.0


    - name: Set up Go
      uses: actions/setup-go@v6.1.0
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Download all test artifacts
      uses: actions/download-artifact@v6
      with:
        pattern: "*test-results"
        path: test-results
        merge-multiple: true

    - name: Generate comprehensive coverage report
      run: |
        # Run all tests together for combined coverage
        make test-coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v5
      with:
        file: ./coverage.html
        flags: unittests,integration,e2e
        name: codecov-umbrella
        fail_ci_if_error: false

  # Lightweight check for documentation-only changes
  docs-only:
    name: Documentation Only
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.docs == 'true' && needs.changes.outputs.code == 'false' && needs.changes.outputs.ci == 'false'
    steps:
    - name: Checkout code
      uses: actions/checkout@v6.0.0

    - name: Check for typos
      uses: crate-ci/typos@v1.27.3

    - name: Validate markdown files
      run: |
        # Check that markdown files are properly formatted
        find . -name "*.md" -exec echo "Validating {}" \;

  # Final status check
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [changes, unit-tests-and-lint, integration-tests, e2e-tests, build, coverage, docs-only]
    if: always()
    steps:
    - name: Check CI status
      run: |
        # Check if this is docs-only change
        if [[ "${{ needs.changes.outputs.docs }}" == "true" && "${{ needs.changes.outputs.code }}" == "false" && "${{ needs.changes.outputs.ci }}" == "false" ]]; then
          echo "Documentation-only change detected"
          if [[ "${{ needs.docs-only.result }}" != "success" ]]; then
            echo "Documentation validation failed"
            exit 1
          fi
          echo "Documentation validation passed successfully!"
        else
          echo "Code or CI changes detected - checking full test suite"
          if [[ "${{ needs.unit-tests-and-lint.result }}" != "success" ]]; then
            echo "Unit tests or linting failed"
            exit 1
          fi
          if [[ "${{ needs.integration-tests.result }}" != "success" ]]; then
            echo "Integration tests failed"
            exit 1
          fi
          if [[ "${{ needs.e2e-tests.result }}" != "success" ]]; then
            echo "E2E tests failed"
            exit 1
          fi
          if [[ "${{ needs.build.result }}" != "success" ]]; then
            echo "Build failed"
            exit 1
          fi
          echo "All CI checks passed successfully!"
        fi